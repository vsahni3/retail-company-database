"""
Author Names : Varun Sahni, Junyuan Chen
Folder Name: classes
File Name: employee_class.py
Date and time completed: 2022-01-07 12:45
Assignment Name: Company Database Project
TODO: Create a class to represent the employees SQL table which has many useful methods and can create Employee instances.
"""

import datetime

from classes.abstract_class import SQLTable, use_cursor


class Employee(SQLTable):
    """
    Employee class will create instances of Employee. Each employee will have a unique id, salted hash (hashed password with an added input for security), permission level, name, email, hire date, position, salary, phone number and the id for the immediate manager.

    Employeec class will override all of the abstract methods from the SQLTable class using their own implementation.

    You can also load the employee's manager by calling the load method using the manager id.
    """

    def __init__(self, id, salted_hash, permission, name,
                 email, phone_number, hire_date, position,
                 salary, manager_id):
        """
        Initialize the attributes of each Employee object.
        To create an instance of an employee, enter the following arguments:
            id (int) - the unique employee id
            salted_hash (str) - the password hashed with salt (an input) for added security and to ensure the passswords will always be unique
            permission (int) - the permission level of the employee
            name (str) - the employee name
            email (str) - the employee email
            hire_date (str) - the date the employee was hired
            position (str) - the employee's position in the company
            salary (int) - the employee's yearly salary
            manager_id (int) - the id of the employee's direct manager
            phone_number (str) - the employee's phone number
            """

        self.id = id
        self._salted_hash = salted_hash
        self.permission = permission
        self.name = name
        self.email = email
        self.phone_number = phone_number
        self.hire_date = hire_date
        self.position = position
        self.salary = salary
        self.manager_id = manager_id

    def __str__(self):
        """
        Return string representation using the id, name, email and if/whether the employee is a manager or the owner

        Returns:
            (str) - the string representation
        """

        base = f"[ID: {self.id}] {self.name} <{self.email}>"
        if self.permission == 1:
            return f"{base} (Manager)"
        if self.permission == 2:
            return f"{base} (Owner)"
        return base

    def get_salted_hash(self):
        """
        Getter for salted_hash, which is sensitive info

        Returns:
            self._salted_hash (str) - the salted hash password
        """

        return self._salted_hash

    def set_salted_hash(self, new_salted_hash):
        """
        Set salted hash, which is sensitive info, with a new value

        Returns:
            self._salted_hash (str) - the salted hash password
        """

        self._salted_hash = new_salted_hash

    def output_info(self):
        print(f"Employee {self}")
        print(f"Position: {self.position}")
        print(f"Access Level: {self.permission}")
        print(f"Manager: {self.load_manager()}")
        print(f"Phone: {self.phone_number}")
        print(f"Salary: ${self.salary}")
        print(f"Hire date: {self.hire_date}")


    @use_cursor
    def _insert(self, cur):
        """
        Insert a new row to the employee table using an Employee object. Get the employee id from the table (autogenerated) to be used when printing the employee's info

        Arguments:
            cur (sqlite3 Cursor object) - the cursor to be used to interact with the sql tables
        """

        cur.execute(
            "INSERT INTO employees (salted_hash, permission, name, "
            "email, hire_date, position, salary, manager_id, phone_number) "
            "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)",
            [
                self._salted_hash, self.permission, self.name, self.email,
                self.hire_date, self.position, self.salary, self.manager_id, self.phone_number
            ]
        )
        self.id = cur.lastrowid

    @use_cursor
    def _update(self, cur):
        """
        Update an existing row using an Employee object. After loading the Employee object to represent the row, one of the values of the object will be changed and then the row will be updated.

        Arguments:
            cur (sqlite3 Cursor object) - the cursor to be used to interact with the sql tables
        """
        cur.execute(
            "UPDATE employees SET salted_hash = ?, permission = ?, "
            "name = ?, email = ?, hire_date = ?, position = ?, "
            "salary = ?, manager_id = ?, phone_number = ? WHERE id = ?",
            [
                self._salted_hash, self.permission, self.name,
                self.email, self.hire_date, self.position,
                self.salary, self.manager_id, self.phone_number, self.id
            ]
        )

    @use_cursor
    def destroy(self, cur):
        """
        Delete a row from the table

        Arguments:
            cur (sqlite3 Cursor object) - the cursor to be used to interact with the sql tables
        """
        cur.execute("DELETE FROM employees WHERE id = ?", [self.id])

    def load_manager(self):
        """
        Load the employee's manager by calling load on the manager's id

        Returns:
            (Employee object) - the manager Employee object
        """
        if self.manager_id is None:
            return None
        return Employee.load(self.manager_id)

    @staticmethod
    def new():
        """
        Create a new employee object using placeholder values. The hire date will be autogenerated.

        Returns:
            (Employee object) - the newly created Employee object
        """
        now = datetime.datetime.now() - datetime.timedelta(hours = 5)
        hire_date = now.strftime("%Y-%m-%d")
        return Employee(0, "", 0, None, None, None, hire_date, None, None, None)

    @staticmethod
    @use_cursor
    def load(id, cur):
        """
        Load an Employee object using the id and the load_where method. Raise KeyError if the id does not exist in the table

        Arguments:
            id (int) - the employee id

        Returns:
            (Employee object) - the employee reprsenting the row
        """
        #we can use load where
        employee = Employee.load_where("id = ?", [id])
        if employee:
            return employee[0]
        raise KeyError(id)

    @staticmethod
    def load_all():
        """
        Load all of the employees in the table by calling the load_where method

        Returns:
            result (list) - a list containing the Employee objects
        """
        return Employee.load_where("1")


    @staticmethod
    @use_cursor
    def load_where(where, args=[], cur=None):
        """
        Load Employee objects representing rows which meet a certain condition

        Arguments:
            where (str) - the 'type' of condition which is being checked (for eg: salary > ?)
            args (list) - a list containing the values used to check in the condition (for eg: [50000])
            cur (sqlite3 Cursor object) - the cursor to be used to interact with the sql tables

        Returns:
            (list) - a list of Employee objects that meet the condition
        """
        result = []
        cur.execute(
            f"SELECT id, salted_hash, permission, name, email, phone_number, hire_date, "
            f"position, salary, manager_id FROM employees WHERE {where}",
            args
        )
        for data in cur.fetchall():
            (id, salted_hash, permission, name, email, phone_number,
             hire_date, position, salary, manager_id) = data

            result.append(Employee(id, salted_hash, permission, name, email, phone_number, hire_date, position, salary, manager_id))

        return result

    @staticmethod
    def load_many(ids):
        """
        Load multiple Employee objects/rows using a list of ids and load_where

        Arguments:
            ids - the list of ids to use to load objects

        Returns:
            (list) - a list of Employee objects, one for every id
        """
        args = ", ".join(["?"] * len(ids))
        return Employee.load_where(f"id IN ({args})", ids)

